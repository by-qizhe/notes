# jvm内存区域
jvm平台整个都运行在内存中，其所在的内存通过划分，各尽职责的管辖着语言的运行协调过程，内存区域区分合理
能够使得管理起来更加方便、易于扩展等好处，下面列下jvm的内存区域：

- 虚拟机栈（VM Stack）；
- 本地方法栈（Native Method Stack）；
- 方法区（Method Area）/永久代（Perm Gen）/元空间（Metaspace）；
- 堆（Heap）；
- PC程序计数器（Program Counter）；

## 虚拟机栈（VM Stack）
虚拟机栈负责管理Java方法的所有，如方法调用链、局部变量存储、四则运算等。栈中的基本单位为栈帧（Stack Frame），一个栈帧代表
一个方法，其实总体上看，虚拟机栈是一个桶，桶的基本单位是栈帧，这个桶的遵循后进先出LIFO规则，即出栈入栈，这种LIFO规则刚好与
方法调用的层级一样（第一个方法肯定是最晚结束）。而虚拟机栈无需jvm回收，其会保证在方法执行完毕后自动回收内存，当然，若内存不足
时，还是会触发OutOfMemoryError

### 栈帧结构
刚刚说到，虚拟机栈的基本单位是栈帧，栈帧主要组成部分有如下：

- 局部变量表（local variable table）：存储着当前方法的局部变量信息，每个方法需要多少个位置来存放局部变量
                                     都会在编译期决定，并且这些位置是允许重用的，即当某个局部变量失效后，
                                     该位置就可被其它局部变量使用，这种机制能够提高内存使用率，当需要的位置
                                     超过深度时，会触发StackOverFlowError，而当空间不足无法分配时，会触发
                                     OutOfMemoryError；
- 操作数栈（operand stack）：操作数栈负责四则运算，通过从局部变量表中取出变量进行运算，然后再返回局部变量表中；
- 返回地址（return address）：当前方法执行完毕后，其将执行结果返回到该地址上，通常来说返回地址有两种，一种是正常
                             返回，而另外一种是异常返回，不管是哪种，都会确保该方法执行结束后能够返回调用该方法的
                             位置上；
- 动态链接（dynamic link）：指向方法区/永久代/元空间的方法描述信息；

## 本地方法栈
与虚拟机栈相似，处理的是非Java语言的方法，通常都是JVM层面上的C++方法；

## 方法区（Method Area）/永久代（Perm Gen）/元空间（Metaspace）
把这三者都放在一起，那是因为三者存放的信息都是差不多的。方法区是jvm规范中定义的名字，而永久代是HotSpot VM（遵守了jvm规范的虚拟机）
特有的概念，永久代与方法区是一致的。而元空间是jdk8用来取代方法区的。

### 方法区、永久代
不管是方法区，还是永久代，其内存结构如下：

- 运行时常量池（Runtime Constant Pool）：
    - 包装类常量池：如Integer包装类的值缓存（-127 - 128）；
    - 类常量池：每个类被编译器编译后，都会有与其匹配的常量池信息；
    - 字符串常量池：jdk6及以下，还是存放在方法区/永久代中的运行时常量池，而在jdk7，单独将字符串常量池移动到了heap；
- 类的元数据（Class Meta）：类的定义信息；
- 静态变量（Static Variable）；



